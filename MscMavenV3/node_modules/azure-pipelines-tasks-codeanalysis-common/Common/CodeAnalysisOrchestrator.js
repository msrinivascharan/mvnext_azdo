"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeAnalysisOrchestrator = void 0;
const CodeAnalysisResultPublisher_1 = require("./CodeAnalysisResultPublisher");
const path = require("path");
const tl = require("azure-pipelines-task-lib/task");
/**
 * Orcheestrates the processing and publishing of code analysis data and artifacts (PMD, FindBugs etc. but not SonarQube)
 *
 * @export
 * @class CodeAnalysisOrchestrator
 */
class CodeAnalysisOrchestrator {
    constructor(tools) {
        this.tools = tools;
    }
    configureBuild(toolRunner) {
        if (this.checkBuildContext()) {
            for (let tool of this.tools) {
                toolRunner = tool.configureBuild(toolRunner);
            }
        }
        return toolRunner;
    }
    /**
     * Parses the code analysis tool results (PMD, CheckStyle .. but not SonarQube). Uploads reports and artifacts.
     */
    publishCodeAnalysisResults() {
        if (this.checkBuildContext() && this.tools.length > 0) {
            tl.debug(`[CA] Attempting to find report files from ${this.tools.length} code analysis tool(s)`);
            let analysisResults = this.processResults(this.tools);
            if (analysisResults.length < 1) {
                tl.debug('[CA] Skipping artifact upload: No analysis results');
                return;
            }
            let stagingDir = path.join(tl.getVariable('build.artifactStagingDirectory'), '.codeAnalysis');
            let buildNumber = tl.getVariable('build.buildNumber');
            let resultPublisher = new CodeAnalysisResultPublisher_1.CodeAnalysisResultPublisher(analysisResults, stagingDir);
            let uploadedArtifacts = resultPublisher.uploadArtifacts(buildNumber);
            resultPublisher.uploadBuildSummary(uploadedArtifacts);
        }
    }
    processResults(tools) {
        let analysisResults = [];
        for (let tool of tools) {
            let results = tool.processResults();
            if (results !== undefined && results !== null && results.length > 0) {
                analysisResults = analysisResults.concat(results);
            }
        }
        return analysisResults;
    }
    checkBuildContext() {
        let requiredVariables = ['System.DefaultWorkingDirectory', 'build.artifactStagingDirectory', 'build.buildNumber'];
        for (let requiredVariable of requiredVariables) {
            if (!tl.getVariable(requiredVariable)) {
                console.log(tl.loc('codeAnalysisDisabled', requiredVariable));
                return false;
            }
        }
        return true;
    }
}
exports.CodeAnalysisOrchestrator = CodeAnalysisOrchestrator;
