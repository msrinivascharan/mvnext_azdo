"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckstyleTool = void 0;
const BuildOutput_1 = require("./BuildOutput");
const BaseTool_1 = require("./BaseTool");
const path = require("path");
const fs = require("fs");
const glob = require("glob");
const xml2js = require("xml2js");
const tl = require("azure-pipelines-task-lib/task");
/**
 * An object that is able to configure the build to run PMD and identify and parse PMD reports
 *
 * @export
 * @class PmdReportParser
 * @implements {IAnalysisToolReportParser}
 */
class CheckstyleTool extends BaseTool_1.BaseTool {
    constructor(buildOutput, boolInputName) {
        super('Checkstyle', buildOutput, boolInputName);
    }
    /**
     * Configures the provided ToolRunner instance with arguments which will invoke the tool represented by this class.
     * @param toolRunner
     * @returns {ToolRunner} ToolRunner instance with arguments applied
     */
    configureBuild(toolRunner) {
        if (this.isEnabled()) {
            console.log(tl.loc('codeAnalysis_ToolIsEnabled'), this.toolName);
            switch (this.buildOutput.buildEngine) {
                case BuildOutput_1.BuildEngine.Maven:
                    toolRunner.arg(['checkstyle:checkstyle']);
                    break;
                case BuildOutput_1.BuildEngine.Gradle:
                    let initScriptPath = path.join(__dirname, '..', 'checkstyle.gradle');
                    toolRunner.arg(['-I', initScriptPath]);
                    break;
                default:
                    break;
            }
        }
        return toolRunner;
    }
    /**
     * Implementers must specify where the XML reports are located
     */
    getBuildReportDir(output) {
        switch (this.buildOutput.buildEngine) {
            case BuildOutput_1.BuildEngine.Maven:
                return path.join(output.moduleRoot);
            case BuildOutput_1.BuildEngine.Gradle:
                return path.join(output.moduleRoot, 'reports', 'checkstyle');
            default:
                tl.debug('No such build engine ' + this.buildOutput.buildEngine);
                throw new Error();
        }
    }
    /**
     * Report parser that extracts the number of affected files and the number of violations from a report
     *
     * @returns a tuple of [affected_file_count, violation_count]
     */
    parseXmlReport(xmlReport, moduleName) {
        let fileCount = 0;
        let violationCount = 0;
        let reportContent = fs.readFileSync(xmlReport, 'utf-8');
        xml2js.parseString(reportContent, (err, data) => {
            // If the file is not XML, or is not from checkstyle, return immediately
            if (!data || !data.checkstyle) {
                tl.debug(`[CA] Empty or unrecognized checkstyle xml report ${xmlReport}`);
                return null;
            }
            // No files with violations, return now that it has been marked for upload
            if (!data.checkstyle.file || data.checkstyle.file.length === 0) {
                tl.debug(`[CA] A checkstyle report was found for module '${moduleName}' but it contains no violations`);
                return null;
            }
            data.checkstyle.file.forEach((file) => {
                if (file.error) {
                    fileCount++;
                    violationCount += file.error.length;
                }
            });
            tl.debug(`[CA] A checkstyle report was found for for module '${moduleName}' containing ${violationCount} issues - ${xmlReport}`);
        });
        return [violationCount, fileCount];
    }
    findHtmlReport(xmlReport) {
        let dirName = path.dirname(xmlReport);
        let htmlReports;
        // On certain build engines Checkstyle produces an HTML file called "checkstyle.html". If we find it, return it.
        htmlReports = glob.sync(path.join(dirName, '**', 'checkstyle.html'));
        if (htmlReports.length > 0) {
            return htmlReports[0];
        }
        // Otherwise, look for an HTML report with the same name as the XML report.
        let reportName = path.basename(xmlReport, '.xml');
        htmlReports = glob.sync(path.join(dirName, '**', reportName + '.html'));
        if (htmlReports.length > 0) {
            return htmlReports[0];
        }
        return null;
    }
}
exports.CheckstyleTool = CheckstyleTool;
