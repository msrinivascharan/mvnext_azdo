"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readXmlFileAsDom = exports.addPropToJson = exports.writeFile = exports.writeJsonAsXmlFile = exports.convertXmlStringToJson = exports.readFile = exports.readXmlFileAsJson = exports.trimEnd = exports.insertTextToFileSync = exports.prependTextToFileSync = exports.appendTextToFileSync = exports.trimToEmptyString = exports.isNullOrWhitespace = exports.isFileExists = exports.isDirectoryExists = exports.sortStringArray = exports.sharedSubString = void 0;
const Q = require("q");
const fs = require("fs");
const tl = require("azure-pipelines-task-lib/task");
const path = require("path");
const xml2js = require("xml2js");
const fse = require("fs-extra");
const cheerio = require("cheerio");
let stripbom = require("strip-bom");
tl.setResourcePath(path.join(__dirname, 'module.json'), true);
// returns a substring that is common from first. For example, for "abcd" and "abdf", "ab" is returned.
function sharedSubString(string1, string2) {
    let ret = "";
    let index = 1;
    while (string1.substring(0, index) === string2.substring(0, index)) {
        ret = string1.substring(0, index);
        index++;
    }
    return ret;
}
exports.sharedSubString = sharedSubString;
// sorts string array in ascending order
function sortStringArray(list) {
    let sortedFiles = list.sort((a, b) => {
        if (a > b) {
            return 1;
        }
        else if (a < b) {
            return -1;
        }
        return 0;
    });
    return sortedFiles;
}
exports.sortStringArray = sortStringArray;
// returns true if path exists and it is a directory else false.
function isDirectoryExists(path) {
    try {
        return tl.stats(path).isDirectory();
    }
    catch (error) {
        return false;
    }
}
exports.isDirectoryExists = isDirectoryExists;
// returns true if path exists and it is a file else false.
function isFileExists(path) {
    try {
        return tl.stats(path).isFile();
    }
    catch (error) {
        return false;
    }
}
exports.isFileExists = isFileExists;
// returns true if given string is null or whitespace.
function isNullOrWhitespace(input) {
    if (typeof input === "undefined" || input == null) {
        return true;
    }
    return input.replace(/\s/g, "").length < 1;
}
exports.isNullOrWhitespace = isNullOrWhitespace;
// returns empty string if the given value is undefined or null.
function trimToEmptyString(input) {
    if (typeof input === "undefined" || input == null) {
        return "";
    }
    return input.trim();
}
exports.trimToEmptyString = trimToEmptyString;
// appends given text to file.
function appendTextToFileSync(filePath, fileContent) {
    if (isFileExists(filePath)) {
        fs.appendFileSync(filePath, fileContent);
    }
    else {
        throw new Error(tl.loc("FileNotFound", filePath));
    }
}
exports.appendTextToFileSync = appendTextToFileSync;
// prepends given text to start of file.
function prependTextToFileSync(filePath, fileContent) {
    if (isFileExists(filePath)) {
        let data = fs.readFileSync(filePath); // read existing contents into data
        let fd = fs.openSync(filePath, "w+");
        let buffer = new Buffer(fileContent);
        fs.writeSync(fd, buffer, 0, buffer.length, 0); // write new data
        fs.writeSync(fd, data, 0, data.length, 0); // append old data
        fs.close(fd, (err) => {
            if (err) {
                tl.error(err.message);
            }
        });
    }
}
exports.prependTextToFileSync = prependTextToFileSync;
// single utility for appending text and prepending text to file.
function insertTextToFileSync(filePath, prependFileContent, appendFileContent) {
    if (isFileExists(filePath) && (prependFileContent || appendFileContent)) {
        let existingData = fs.readFileSync(filePath); // read existing contents into data
        let fd = fs.openSync(filePath, "w+");
        let preTextLength = prependFileContent ? prependFileContent.length : 0;
        if (prependFileContent) {
            let prependBuffer = new Buffer(prependFileContent);
            fs.writeSync(fd, prependBuffer, 0, prependBuffer.length, 0); // write new data
        }
        fs.writeSync(fd, existingData, 0, existingData.length, preTextLength); // append old data
        if (appendFileContent) {
            let appendBuffer = new Buffer(appendFileContent);
            fs.writeSync(fd, appendBuffer, 0, appendBuffer.length, existingData.length + preTextLength);
        }
        fs.close(fd, (err) => {
            if (err) {
                tl.error(err.message);
            }
        });
    }
}
exports.insertTextToFileSync = insertTextToFileSync;
// trim the given character if it exists in the end of string.
function trimEnd(data, trimChar) {
    if (!trimChar || !data) {
        return data;
    }
    if (data.endsWith(trimChar)) {
        return data.substring(0, data.length - trimChar.length);
    }
    else {
        return data;
    }
}
exports.trimEnd = trimEnd;
function readXmlFileAsJson(filePath) {
    tl.debug("Reading XML file: " + filePath);
    return readFile(filePath, "utf-8")
        .then(convertXmlStringToJson);
}
exports.readXmlFileAsJson = readXmlFileAsJson;
function readFile(filePath, encoding) {
    return Q.nfcall(fs.readFile, filePath, encoding);
}
exports.readFile = readFile;
function convertXmlStringToJson(xmlContent) {
    tl.debug("Converting XML file to JSON");
    return Q.nfcall(xml2js.parseString, stripbom(xmlContent));
}
exports.convertXmlStringToJson = convertXmlStringToJson;
function writeJsonAsXmlFile(filePath, jsonContent) {
    let builder = new xml2js.Builder();
    tl.debug("Writing JSON as XML file: " + filePath);
    let xml = builder.buildObject(jsonContent);
    xml = xml.replace(/&#xD;/g, "");
    return writeFile(filePath, xml);
}
exports.writeJsonAsXmlFile = writeJsonAsXmlFile;
function writeFile(filePath, fileContent) {
    tl.debug("Creating dir if not exists: " + path.dirname(filePath));
    fse.mkdirpSync(path.dirname(filePath));
    tl.debug("Check dir: " + fs.existsSync(path.dirname(filePath)));
    return Q.nfcall(fs.writeFile, filePath, fileContent, { encoding: "utf-8" });
}
exports.writeFile = writeFile;
function addPropToJson(obj, propName, value) {
    tl.debug("Adding property to JSON: " + propName);
    if (typeof obj === "undefined") {
        obj = {};
    }
    if (obj instanceof Array) {
        let propNode = obj.find(o => o[propName]);
        if (propNode) {
            obj = propNode;
        }
    }
    if (propName in obj) {
        if (obj[propName] instanceof Array) {
            obj[propName].push(value);
        }
        else if (typeof obj[propName] !== "object") {
            obj[propName] = [obj[propName], value];
        }
    }
    else if (obj instanceof Array) {
        let prop = {};
        prop[propName] = value;
        obj.push(prop);
    }
    else {
        obj[propName] = value;
    }
}
exports.addPropToJson = addPropToJson;
function readXmlFileAsDom(filePath) {
    tl.debug("Reading XML file: " + filePath);
    return cheerio.load(stripbom(fs.readFileSync(filePath, "utf-8")), { xmlMode: true, withDomLvl1: false });
}
exports.readXmlFileAsDom = readXmlFileAsDom;
