"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JacocoMavenCodeCoverageEnabler = void 0;
const util = require("../utilities");
const tl = require("azure-pipelines-task-lib/task");
const ccc = require("../codecoverageconstants");
const cc = require("../codecoverageenabler");
const Q = require("q");
const path = require("path");
tl.setResourcePath(path.join(path.dirname(__dirname), 'module.json'), true);
class JacocoMavenCodeCoverageEnabler extends cc.JacocoCodeCoverageEnabler {
    // -----------------------------------------------------
    // Enable code coverage for Jacoco Maven Builds
    // - enableCodeCoverage: CodeCoverageProperties  - ccProps
    // -----------------------------------------------------
    enableCodeCoverage(ccProps) {
        let _this = this;
        tl.debug("Input parameters: " + JSON.stringify(ccProps));
        _this.buildFile = ccProps["buildfile"];
        _this.reportDir = ccProps["reportdirectory"];
        _this.sourceDirs = ccProps["sourcedirectories"];
        _this.classDirs = ccProps["classfilesdirectories"];
        _this.reportBuildFile = ccProps["reportbuildfile"];
        let classFilter = ccProps["classfilter"];
        let filter = _this.extractFilters(classFilter);
        _this.excludeFilter = _this.applyFilterPattern(filter.excludeFilter);
        _this.includeFilter = _this.applyFilterPattern(filter.includeFilter);
        return util.readXmlFileAsJson(_this.buildFile)
            .then(function (resp) {
            return _this.addCodeCoverageData(resp);
        })
            .thenResolve(true);
    }
    applyFilterPattern(filter) {
        let ccfilter = [];
        if (!util.isNullOrWhitespace(filter)) {
            util.trimToEmptyString(filter).replace(/\./g, "/").split(":").forEach(exFilter => {
                if (exFilter) {
                    ccfilter.push(exFilter.endsWith("*") ? ("**/" + exFilter + "/**") : ("**/" + exFilter + ".class"));
                }
            });
        }
        tl.debug("Applying the filter pattern: " + filter + " op: " + ccfilter);
        return ccfilter;
    }
    addCodeCoverageData(pomJson) {
        let _this = this;
        if (!pomJson.project) {
            Q.reject(tl.loc("InvalidBuildFile"));
        }
        let isMultiModule = false;
        if (pomJson.project.modules) {
            tl.debug("Multimodule project detected");
            isMultiModule = true;
        }
        let promises = [_this.addCodeCoveragePluginData(pomJson)];
        if (isMultiModule) {
            promises.push(_this.createMultiModuleReport(_this.reportDir));
        }
        return Q.all(promises);
    }
    addCodeCoverageNodes(buildJsonContent) {
        let _this = this;
        let buildNode = _this.getBuildDataNode(buildJsonContent);
        let pluginsNode = _this.getPluginDataNode(buildNode);
        let ccContent = ccc.jacocoMavenPluginEnable(_this.includeFilter, _this.excludeFilter, _this.reportDir);
        util.addPropToJson(pluginsNode, "plugin", ccContent);
        return Q.resolve(buildJsonContent);
    }
    getBuildDataNode(buildJsonContent) {
        let buildNode = null;
        if (!buildJsonContent.project.build || typeof buildJsonContent.project.build === "string") {
            buildNode = {};
            buildJsonContent.project.build = buildNode;
        }
        else if (buildJsonContent.project.build instanceof Array) {
            if (typeof buildJsonContent.project.build[0] === "string") {
                buildNode = {};
                buildJsonContent.project.build[0] = buildNode;
            }
            else {
                buildNode = buildJsonContent.project.build[0];
            }
        }
        return buildNode;
    }
    getPluginDataNode(buildNode) {
        let pluginsNode = {};
        /* Always look for plugins node first */
        if (buildNode.plugins) {
            if (typeof buildNode.plugins === "string") {
                buildNode.plugins = {};
            }
            if (buildNode.plugins instanceof Array) {
                if (typeof buildNode.plugins[0] === "string") {
                    pluginsNode = {};
                    buildNode.plugins[0] = pluginsNode;
                }
                else {
                    pluginsNode = buildNode.plugins[0];
                }
            }
            else {
                pluginsNode = buildNode.plugins;
            }
        }
        else {
            buildNode.plugins = {};
            pluginsNode = buildNode.plugins;
        }
        return pluginsNode;
    }
    createMultiModuleReport(reportDir) {
        let _this = this;
        let srcDirs = _this.sourceDirs;
        let classDirs = _this.classDirs;
        let includeFilter = _this.includeFilter.join(",");
        let excludeFilter = _this.excludeFilter.join(",");
        if (util.isNullOrWhitespace(srcDirs)) {
            srcDirs = ".";
        }
        if (util.isNullOrWhitespace(classDirs)) {
            classDirs = ".";
        }
        return util.writeFile(_this.reportBuildFile, ccc.jacocoMavenMultiModuleReport(reportDir, srcDirs, classDirs, includeFilter, excludeFilter));
    }
    addCodeCoveragePluginData(pomJson) {
        let _this = this;
        return _this.addCodeCoverageNodes(pomJson)
            .then(function (content) {
            return util.writeJsonAsXmlFile(_this.buildFile, content);
        });
    }
}
exports.JacocoMavenCodeCoverageEnabler = JacocoMavenCodeCoverageEnabler;
